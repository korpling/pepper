<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pepper: Pepper as a library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pepper.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pepper
   &#160;<span id="projectnumber">3.6.0</span>
   </div>
   <div id="projectbrief">A highly extensible plattform for conversion and manipulationoflinguisticdata.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('library.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Pepper as a library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>With the Pepper library, we provide a programmatic access to the Pepper framework, including the configuration of a conversion workflow, the start of a conversion and getting information about the registered Pepper modules. Since Pepper is based on a plugin structure called OSGi (see: <a href="http://www.osgi.org/">http://www.osgi.org/</a>), each Pepper module is plugged into the framework separately, whether running Pepper as CLI, or running it as a library. The Pepper framework consists of two necessary components: a jar file, which can be included in your software project via maven, and a plugin folder containing all Pepper modules. The following excerpt shows the necessary maven coordinates.</p>
<div class="fragment"><div class="line">&lt;dependency&gt;</div>
<div class="line">   &lt;artifactId&gt;pepper-lib&lt;/artifactId&gt;</div>
<div class="line">   &lt;groupId&gt;org.corpus-tools&lt;/groupId&gt;</div>
<div class="line">   &lt;version&gt;3.6.0&lt;/version&gt;</div>
<div class="line">&lt;/dependency&gt;</div>
</div><!-- fragment --><p>When Pepper is included in your project, you need to get all necessary plugins and modules, therefore: </p><ol>
<li>
Download a Pepper release of your choice from <a href="http://corpus-tools.org/pepper/">http://corpus-tools.org/pepper/</a> </li>
<li>
Unzip the downloaded zip file </li>
<li>
Copy the contained folder plugins to a folder of your choice, let's call it PLUGINS_HOME. </li>
</ol>
<p>Now you can start coding. Here is a template, showing how to initialize a Pepper object.</p>
<div class="fragment"><div class="line">PepperStarterConfiguration pepperConf = new PepperStarterConfiguration();</div>
<div class="line">pepperConf.setProperty(PepperStarterConfiguration.PROP_PLUGIN_PATH, PATH_TO_PLUGINS);</div>
<div class="line">PepperConnector pepper = new PepperOSGiConnector();</div>
<div class="line">pepper.setConfiguration(pepperConf);</div>
<div class="line">pepper.init();</div>
</div><!-- fragment --><p>Let's have some code explanations with that:</p>
<p>In line 1, we initialize a configuration object to configure the Pepper framework before starting it. Line 2 sets the plugin folder. Please replace the placeholder "PLUGIN_HOME" with the real location. The configuration provides some more adaptation possibilities, just have a look at the JavaDoc or the class itself.</p>
<p>In line 3, we initialize the proper Pepper object symbolising the Pepper framework. In the future, there may be several connectors to access the framework, e.g. to access a Pepper instance running on a remote server. But currently there is just an OSGi connector, which starts a separate OSGi environment (Pepper uses the OSGi environment Equinox, see <a href="http://www.eclipse.org/equinox/">http://www.eclipse.org/equinox/</a>).</p>
<p>The last line of code passes the configuration to the Pepper object. Pepper is configured now and we are ready to use it. Before we start a conversion workflow, we show how to query the registered modules. The following snippet prints all information about a module to standard out.</p>
<div class="fragment"><div class="line">for (PepperModuleDesc moduleDesc: pepper.getRegisteredModules()){</div>
<div class="line">    System.out.println(moduleDesc.getName());</div>
<div class="line">    System.out.println(moduleDesc.getVersion());</div>
<div class="line">    System.out.println(moduleDesc.getDesc());</div>
<div class="line">    System.out.println(moduleDesc.getModuleType());</div>
<div class="line">    System.out.println(moduleDesc.getSupplierContact());</div>
<div class="line">    System.out.println(moduleDesc.getSupportedFormats());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we show how to create a single workflow in Pepper and how to run it. In Pepper, a workflow is called a job and is represented by the class PepperJob. A job consists of several steps. A step can handle an importer, a manipulator or an exporter. A job can contain 1 to n importers, 0 to n manipulators and 1 to n exporters. When using an importer or an exporter, we need to describe the corpus to be im- and exported. The following snippet shows the creation of a corpus description, containing the location of the corpus and a description of the format of the corpus.</p>
<div class="fragment"><div class="line">CorpusDesc corpusExport= new CorpusDesc().setCorpusPath(URI.createFileURI(&quot;CORPUS_PATH&quot;));</div>
<div class="line">corpusExport.getFormatDesc().setFormatName(&quot;NAME_OF_FORMAT&quot;);</div>
<div class="line">corpusExport.getFormatDesc().setFormatVersion(&quot;VERSION_OF_FORMAT&quot;);</div>
<div class="line"> </div>
<div class="line">CorpusDesc corpusImport= new CorpusDesc().setCorpusPath(URI.createFileURI(&quot;CORPUS_PATH&quot;));</div>
<div class="line">corpusImport.getFormatDesc().setFormatName(&quot;NAME_OF_FORMAT&quot;);</div>
<div class="line">corpusImport.getFormatDesc().setFormatVersion(&quot;VERSION_OF_FORMAT&quot;);</div>
<div class="line"> </div>
<div class="line">String jobId= pepper.createJob();</div>
<div class="line">PepperJob job= pepper.getJob(jobId);</div>
<div class="line">job.addStepDesc(new StepDesc().setProps(new Properties()).setCorpusDesc(corpusImport));</div>
<div class="line">job.addStepDesc(new StepDesc().setProps(new Properties()).setCorpusDesc(corpusExport));</div>
<div class="line"> </div>
<div class="line">//start conversion</div>
<div class="line">job.convert(); </div>
</div><!-- fragment --><p>Here we create two corpora (line 1-4 and line 10-13) and two steps (line 6-8 and 15-17), one for the import and one for the export. When creating a step, you can also pass some properties for customization. For detailed description of which properties are available corresponding to a specific module, please take a look at the documentation of the Pepper module. After creating the steps, we need to add them to the job (line 21-22). So the last thing to do is to start the job with invoking the method 'convert()' (line 24). Another way of converting a job is converting a predefined workflow file. The following snippet shows how to do this.</p>
<div class="fragment"><div class="line">String jobId= pepper.createJob();</div>
<div class="line">PepperJob pepperJob= pepper.getJob(jobId);</div>
<div class="line">pepperJob.load(&quot;URI_OF_WORKFLOW_FILE&quot;);</div>
<div class="line">pepperJob.convert();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
Import data</h1>
<p>With Pepper you can just import data into a Salt model for further processing in your application. Therefore you need to define an import step and start the conversion via <b><em>convertFrom()</em></b> instead of <em>convert()</em>.</p>
<div class="fragment"><div class="line">job.addStepDesc(new StepDesc().setName(IMPORTER_NAME).setCorpusDesc(new CorpusDesc().setCorpusPath(URI.createFileURI(PATH_TO_CORPUS))).setModuleType(MODULE_TYPE.IMPORTER));</div>
<div class="line"> </div>
<div class="line">job.convertFrom();</div>
</div><!-- fragment --><p>Afterwards, you can access the Salt model and work with it. </p><div class="fragment"><div class="line">job.getSaltProject();</div>
</div><!-- fragment --><p><b> Attention: If your main application is not part of the OSGi environment, you can run into class loader exceptions when accessing Pepper. To avoid such exceptions, read <a class="el" href="library.html#bridgeOSGi">Bridging OSGi</a>. </b></p>
<h1><a class="anchor" id="autotoc_md34"></a>
Export data</h1>
<p>With Pepper you can create a Salt model in your main application and export it to any supported format. Therefore you need to define an export step and start the conversion via <b><em>convertTo()</em></b> instead of <em>convert()</em>. Define your model via: </p><div class="fragment"><div class="line">job.getSaltProject();</div>
</div><!-- fragment --><p>Afterwards, you can export it with:</p>
<div class="fragment"><div class="line">job.addStepDesc(new StepDesc().setName(EXPORTER_NAME).setCorpusDesc(new CorpusDesc().setCorpusPath(URI.createFileURI(PATH_TO_CORPUS))).setModuleType(MODULE_TYPE.EXPORTER));</div>
<div class="line"> </div>
<div class="line">job.convertFrom();</div>
</div><!-- fragment --><p><b>Attention: If your main application is not part of the OSGi environment, you can run into class loader exceptions when accessing Pepper. To avoid such exceptions, read <a class="el" href="library.html#bridgeOSGi">Bridging OSGi</a>. </b></p>
<h1><a class="anchor" id="bridgeOSGi"></a>
Bridging OSGi</h1>
<p>Since Pepper is running in an OSGi container, it uses a different class loader than your main application. When you now try to access Salt model elements, it can happen that you get a class loader exception. To avoid that, Pepper offers you a mechanism to bridge objects from your main application to OSGi and back. Therefore it is necessary to register all concerning packages before Pepper is initialized. The following snippet shows this mechanism:</p>
<div class="fragment"><div class="line">PepperOSGiConnector pepper = new PepperOSGiConnector();</div>
<div class="line">pepper.addSharedPackage(&quot;org.corpus_tools.salt&quot;, &quot;3&quot;);</div>
<div class="line">pepper.addSharedPackage(&quot;org.corpus_tools.salt.common&quot;, &quot;3&quot;);</div>
<div class="line">pepper.addSharedPackage(&quot;org.corpus_tools.salt.core&quot;, &quot;3&quot;);</div>
<div class="line">pepper.addSharedPackage(&quot;org.corpus_tools.salt.graph&quot;, &quot;3&quot;);</div>
<div class="line">pepper.addSharedPackage(&quot;org.corpus_tools.salt.util&quot;, &quot;3&quot;);             </div>
<div class="line">pepper.init();</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="users.html">Pepper users</a></li>
    <li class="footer">Generated on Mon Mar 1 2021 11:46:17 for Pepper by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>